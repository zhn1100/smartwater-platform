{"version":3,"file":"uri-utils.js","sourceRoot":"","sources":["../../../src/parser/uri-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Char } from '../char';\nimport {\n    isDigitChar,\n    isAsciiLetterChar,\n    isAlphaNumericOrMarkChar,\n    isUrlSuffixAllowedSpecialChar,\n    isUrlSuffixNotAllowedAsFinalChar,\n} from '../char-utils';\nimport { tldRegex } from './known-tlds';\n\n/**\n * Regular expression to match an http:// or https:// scheme.\n */\nexport const httpSchemeRe = /https?:\\/\\//i;\n\n/**\n * Regular expression to match an http:// or https:// scheme as the prefix of\n * a string.\n */\nexport const httpSchemePrefixRe = new RegExp('^' + httpSchemeRe.source, 'i');\n\n/**\n * A regular expression used to determine the schemes we should not autolink\n */\nexport const invalidSchemeRe = /^(javascript|vbscript):/i;\n\n// A regular expression used to determine if the URL is a scheme match (such as\n// 'http://google.com', and as opposed to a \"TLD match\"). This regular\n// expression is used to parse out the host along with if the URL has an\n// authority component (i.e. '//')\n//\n// Capturing groups:\n//    1. '//' if the URL has an authority component, empty string otherwise\n//    2. The host (if one exists). Ex: 'google.com'\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport const schemeUrlRe = /^[A-Za-z][-.+A-Za-z0-9]*:(\\/\\/)?([^:/]*)/;\n\n// A regular expression used to determine if the URL is a TLD match (such as\n// 'google.com', and as opposed to a \"scheme match\"). This regular\n// expression is used to help parse out the TLD (top-level domain) of the host.\n//\n// See https://www.rfc-editor.org/rfc/rfc3986#appendix-A for terminology\nexport const tldUrlHostRe = /^(?:\\/\\/)?([^/#?:]+)/; // optionally prefixed with protocol-relative '//' chars\n\n/**\n * Determines if the given character code represents a character that may start\n * a scheme (ex: the 'h' in 'http')\n */\nexport const isSchemeStartChar: (code: number) => boolean = isAsciiLetterChar; // Equivalent to checking the RegExp `/[A-Za-z]/`, but aliased for clarity and maintainability\n\n/**\n * Determines if the given character is a valid character in a scheme (such as\n * 'http' or 'ssh+git'), but only after the start char (which is handled by\n * {@link isSchemeStartChar}.\n */\nexport function isSchemeChar(charCode: number): boolean {\n    return (\n        isAsciiLetterChar(charCode) ||\n        isDigitChar(charCode) ||\n        charCode === Char.Plus || // '+'\n        charCode === Char.Dash || // '-'\n        charCode === Char.Dot // '.'\n    );\n}\n\n/**\n * Determines if the character can begin a domain label, which must be an\n * alphanumeric character and not an underscore or dash.\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport const isDomainLabelStartChar: (charCode: number) => boolean = isAlphaNumericOrMarkChar; // alias function for clarity\n\n/**\n * Determines if the character is part of a domain label (but not a domain label\n * start character).\n *\n * A domain label is a segment of a hostname such as subdomain.google.com.\n */\nexport function isDomainLabelChar(charCode: number): boolean {\n    return charCode === Char.Underscore || isDomainLabelStartChar(charCode);\n}\n\n/**\n * Determines if the character is a path character (\"pchar\") as defined by\n * https://tools.ietf.org/html/rfc3986#appendix-A\n *\n *     pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *\n *     unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *     pct-encoded   = \"%\" HEXDIG HEXDIG\n *     sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                   / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n *\n * Note that this implementation doesn't follow the spec exactly, but rather\n * follows URL path characters found out in the wild (spec might be out of date?)\n */\nexport function isPathChar(charCode: number): boolean {\n    return (\n        isAlphaNumericOrMarkChar(charCode) ||\n        isUrlSuffixAllowedSpecialChar(charCode) ||\n        isUrlSuffixNotAllowedAsFinalChar(charCode) // characters in addition to those allowed by isUrlSuffixAllowedSpecialChar()\n    );\n}\n\n/**\n * Determines if the character given may begin the \"URL Suffix\" section of a\n * URI (i.e. the path, query, or hash section). These are the '/', '?' and '#'\n * characters.\n *\n * See https://tools.ietf.org/html/rfc3986#appendix-A\n */\nexport function isUrlSuffixStartChar(charCode: number): boolean {\n    return (\n        charCode === Char.Slash || // '/'\n        charCode === Char.Question || // '?'\n        charCode === Char.NumberSign // '#'\n    );\n}\n\n/**\n * Determines if the top-level domain (TLD) read in the host is a known TLD.\n *\n * Example: 'com' would be a known TLD (for a host of 'google.com'), but\n * 'local' would not (for a domain name of 'my-computer.local').\n */\nexport function isKnownTld(tld: string) {\n    return tldRegex.test(tld.toLowerCase()); // make sure the tld is lowercase for the regex\n}\n\n/**\n * Determines if the given `url` is a valid scheme-prefixed URL.\n */\nexport function isValidSchemeUrl(url: string): boolean {\n    // If the scheme is 'javascript:' or 'vbscript:', these link\n    // types can be dangerous. Don't link them.\n    if (invalidSchemeRe.test(url)) {\n        return false;\n    }\n\n    const schemeMatch = url.match(schemeUrlRe);\n    if (!schemeMatch) {\n        return false;\n    }\n\n    const isAuthorityMatch = !!schemeMatch![1];\n    const host = schemeMatch![2];\n    if (isAuthorityMatch) {\n        // Any match that has an authority ('//' chars) after the scheme is\n        // valid, such as 'http://anything'\n        return true;\n    }\n\n    // If there's no authority ('//' chars), check that we have a hostname\n    // that looks valid.\n    //\n    // The host must contain at least one '.' char and have a domain label\n    // with at least one letter to be considered valid.\n    //\n    // Accept:\n    //   - git:domain.com (scheme followed by a host\n    // Do not accept:\n    //   - git:something ('something' doesn't look like a host)\n    //   - version:1.0   ('1.0' doesn't look like a host)\n    if (host.indexOf('.') === -1 || !/[A-Za-z]/.test(host)) {\n        // `letterRe` RegExp checks for a letter anywhere in the host string\n        return false;\n    }\n    return true;\n}\n\n/**\n * Determines if the given `url` is a match with a valid TLD.\n */\nexport function isValidTldMatch(url: string): boolean {\n    // TLD URL such as 'google.com', we need to confirm that we have a valid\n    // top-level domain\n    const tldUrlHostMatch = url.match(tldUrlHostRe);\n    if (!tldUrlHostMatch) {\n        // At this point, if the URL didn't match our TLD re, it must be invalid\n        // (highly unlikely to happen, but just in case)\n        return false;\n    }\n\n    const host = tldUrlHostMatch[0];\n    const hostLabels = host.split('.');\n    if (hostLabels.length < 2) {\n        // 0 or 1 host label, there's no TLD. Ex: 'localhost'\n        return false;\n    }\n\n    const tld = hostLabels[hostLabels.length - 1];\n    if (!isKnownTld(tld)) {\n        return false;\n    }\n\n    // TODO: Implement these conditions for TLD matcher:\n    // (\n    //     this.longestDomainLabelLength <= 63 &&\n    //     this.domainNameLength <= 255\n    // );\n\n    return true;\n}\n\n// Regular expression to confirm a valid IPv4 address (ex: '192.168.0.1')\n// TODO: encode this into the state machine so that we don't need to run this\n//       regexp separately to confirm the match\nconst ipV4Re =\n    /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n\n// Regular expression used to split the IPv4 address itself from any port/path/query/hash\nconst ipV4PartRe = /[:/?#]/;\n\n/**\n * Determines if the given URL is a valid IPv4-prefixed URL.\n */\nexport function isValidIpV4Address(url: string): boolean {\n    // Grab just the IP address\n    const ipV4Part = url.split(ipV4PartRe, 1)[0]; // only 1 result needed\n\n    return ipV4Re.test(ipV4Part);\n}\n"]}